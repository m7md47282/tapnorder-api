# Backend Architecture & Coding Standards

## Architecture Patterns

### 1. SOLID Principles & Clean Architecture
- **Single Responsibility Principle**: Each class has one reason to change
- **Open/Closed Principle**: Open for extension, closed for modification
- **Liskov Substitution Principle**: Derived classes can substitute base classes
- **Interface Segregation Principle**: Clients depend only on interfaces they use
- **Dependency Inversion Principle**: High-level modules don't depend on low-level modules

### 2. Layered Architecture (Clean Architecture)
- **Presentation Layer**: Controllers/Handlers (Firebase Functions) - NO BUSINESS LOGIC
- **Application Layer**: Services (Business Logic ONLY) - NO DATA ACCESS
- **Domain Layer**: Entities, Value Objects, Domain Services - PURE BUSINESS RULES
- **Infrastructure Layer**: Repositories, Database Clients, External Services - NO BUSINESS LOGIC

### 3. Repository Pattern (MANDATORY)
- **ALL repositories MUST extend `IBaseRepository<T>` interface**
- **ALL repositories MUST inherit from `BaseRepository<T>` abstract class**
- Implement concrete repositories (Firebase, PostgreSQL, etc.) ONLY for specific database logic
- Repository should handle data persistence concerns ONLY
- **ABSOLUTELY NO business logic in repositories**
- **ABSOLUTELY NO validation in repositories**
- **ABSOLUTELY NO business rules in repositories**

### 4. Service Layer Pattern (BUSINESS LOGIC ONLY)
- **Services contain ALL business logic and orchestration**
- **Services use repositories for data access ONLY**
- **Services handle ALL validation, business rules, and transactions**
- **Services are stateless and injectable**
- **Services implement SOLID principles strictly**
- **Services follow Single Responsibility Principle**
- **Services contain NO data access logic**
- **Services contain NO presentation logic**

### 5. Dependency Injection (MANDATORY)
- **Use constructor injection for ALL dependencies**
- **Prefer interfaces over concrete implementations ALWAYS**
- **Use factory patterns for complex object creation**
- **Follow Dependency Inversion Principle strictly**
- **High-level modules depend on abstractions, not concretions**
- **Use dependency injection container for complex dependency graphs**

## Code Organization

### Directory Structure
```
src/
â”œâ”€â”€ controllers/          # Presentation layer (Firebase Functions)
â”œâ”€â”€ services/            # Business logic layer
â”œâ”€â”€ repositories/        # Data access layer
â”œâ”€â”€ entities/            # Domain models
â”œâ”€â”€ value-objects/       # Immutable value objects
â”œâ”€â”€ domain-services/     # Domain-specific business logic
â”œâ”€â”€ infrastructure/      # External services, database clients
â”œâ”€â”€ shared/              # Utilities, constants, types
â””â”€â”€ middleware/          # Cross-cutting concerns
```

### File Naming Conventions
- **Controllers**: `*.controller.ts` (e.g., `menu.controller.ts`)
- **Services**: `*.service.ts` (e.g., `menu.service.ts`)
- **Repositories**: `*.repository.ts` (e.g., `menu.repository.ts`)
- **Entities**: `*.entity.ts` (e.g., `menu.entity.ts`)
- **Interfaces**: `I*.ts` (e.g., `IMenuRepository.ts`)

## Coding Standards

### 1. TypeScript Best Practices (SOLID COMPLIANT)
- Use strict TypeScript configuration
- **Prefer interfaces over types for object shapes ALWAYS**
- **Use generic types for reusable components**
- **Implement proper error handling with custom error types**
- **Use abstract classes for base implementations**
- **Use interfaces for contracts and abstractions**
- **Follow Interface Segregation Principle**
- **Use composition over inheritance when possible**

### 2. Error Handling (CLEAN CODE)
- **Create custom error classes extending `Error`**
- **Use Result pattern for operations that can fail**
- **Implement proper error logging and monitoring**
- **Return consistent error responses**
- **Use meaningful error messages**
- **Implement proper error hierarchy**
- **Handle errors at appropriate layers**
- **Log errors with context and correlation IDs**

### 3. Validation (SERVICE LAYER ONLY)
- **Use Zod for runtime validation**
- **Validate input at service boundaries ONLY**
- **Implement proper sanitization for user inputs**
- **Use DTOs for data transfer**
- **NO validation in repositories**
- **NO validation in controllers**
- **ALL validation happens in services**
- **Use validation decorators for complex validation rules**

### 7. Testing Database Clients (MANDATORY)
```typescript
// Mock database client for testing
export class MockDatabaseClient implements IDatabaseClient {
  private connected = false;
  
  async connect(): Promise<void> {
    this.connected = true;
  }
  
  async disconnect(): Promise<void> {
    this.connected = false;
  }
  
  isConnected(): boolean {
    return this.connected;
  }
  
  getConnection(): any {
    return { mock: true };
  }
}

// Test the factory
describe('DatabaseClientFactory', () => {
  it('should create Firebase client', () => {
    const config: DatabaseConfig = { type: 'firebase', credentials: {} };
    const client = DatabaseClientFactory.createClient(config);
    expect(client).toBeInstanceOf(FirebaseClient);
  });
  
  it('should create PostgreSQL client', () => {
    const config: DatabaseConfig = { type: 'postgresql', credentials: {} };
    const client = DatabaseClientFactory.createClient(config);
    expect(client).toBeInstanceOf(PostgreSQLClient);
  });
  
  it('should throw error for unsupported type', () => {
    const config: DatabaseConfig = { type: 'unsupported' as any, credentials: {} };
    expect(() => DatabaseClientFactory.createClient(config)).toThrow();
  });
});
```

### 8. Testing
- Write unit tests for services
- Mock repositories in service tests
- Use Jest for testing framework
- Aim for 80%+ code coverage

## Database Patterns

### 1. Database Client Factory Pattern (MANDATORY)
```typescript
// Database Client Factory - Simple and Clean
export class DatabaseClientFactory {
  static createClient(config: DatabaseConfig): IDatabaseClient {
    switch (config.type) {
      case 'firebase':
        return new FirebaseClient(config.credentials);
      case 'postgresql':
        return new PostgreSQLClient(config.credentials);
      case 'mongodb':
        return new MongoDBClient(config.credentials);
      default:
        throw new Error(`Unsupported database type: ${config.type}`);
    }
  }
}

// Configuration-driven selection
export const databaseConfig: DatabaseConfig = {
  type: process.env.DB_TYPE || 'firebase',
  credentials: {
    // Environment-based credentials
  }
};

// Usage in repository
const client = DatabaseClientFactory.createClient(databaseConfig);
```

### 2. Repository Implementation (MANDATORY BASE REPO)
```typescript
// ALL repositories MUST extend BaseRepository
export class MenuRepository extends BaseRepository<Menu> implements IMenuRepository {
  constructor() {
    // Use factory to get appropriate client
    const client = DatabaseClientFactory.createClient(databaseConfig);
    super(client, 'menus');
  }
  
  // Implement ONLY specific business queries
  // ALL CRUD operations come from BaseRepository
  async findByPlaceId(placeId: string): Promise<Menu | null> {
    return this.findOne([{ field: 'placeId', operator: '==', value: placeId }]);
  }
}
```

### 3. Database Client Interfaces (MANDATORY)
```typescript
// Base interface for all database operations
export interface IDatabaseClient {
  connect(): Promise<void>;
  disconnect(): Promise<void>;
  isConnected(): boolean;
  getConnection(): any; // Database-specific connection object
}

// Firebase-specific client
export class FirebaseClient implements IDatabaseClient {
  constructor(private credentials: FirebaseCredentials) {}
  
  async connect(): Promise<void> {
    // Firebase connection logic
  }
  
  async disconnect(): Promise<void> {
    // Firebase disconnection logic
  }
  
  isConnected(): boolean {
    // Firebase connection check
    return true; // Firebase is always connected
  }
  
  getConnection(): any {
    return firebase.app();
  }
}

// PostgreSQL-specific client
export class PostgreSQLClient implements IDatabaseClient {
  constructor(private credentials: PostgresCredentials) {}
  
  async connect(): Promise<void> {
    // PostgreSQL connection logic
  }
  
  async disconnect(): Promise<void> {
    // PostgreSQL disconnection logic
  }
  
  isConnected(): boolean {
    // PostgreSQL connection check
    return this.client?.connected || false;
  }
  
  getConnection(): any {
    return this.client;
  }
}
```

### 4. Transaction Management
- Use database transactions for multi-step operations
- Implement Unit of Work pattern for complex operations
- Handle rollback scenarios gracefully

### 5. Environment Configuration (MANDATORY)
```typescript
// Environment-based database configuration
export interface DatabaseConfig {
  type: 'firebase' | 'postgresql' | 'mongodb';
  credentials: Record<string, unknown>;
  options?: {
    connectionPool?: number;
    timeout?: number;
    retries?: number;
  };
}

// Load configuration from environment
export const getDatabaseConfig = (): DatabaseConfig => {
  const dbType = process.env.DB_TYPE || 'firebase';
  
  if (!['firebase', 'postgresql', 'mongodb'].includes(dbType)) {
    throw new Error(`Invalid database type: ${dbType}`);
  }
  
  return {
    type: dbType as DatabaseConfig['type'],
    credentials: {
      // Load credentials based on database type
      ...(dbType === 'firebase' && {
        projectId: process.env.FIREBASE_PROJECT_ID,
        privateKey: process.env.FIREBASE_PRIVATE_KEY,
        clientEmail: process.env.FIREBASE_CLIENT_EMAIL,
      }),
      ...(dbType === 'postgresql' && {
        host: process.env.POSTGRES_HOST,
        port: process.env.POSTGRES_PORT,
        database: process.env.POSTGRES_DB,
        username: process.env.POSTGRES_USER,
        password: process.env.POSTGRES_PASSWORD,
      }),
    },
    options: {
      connectionPool: parseInt(process.env.DB_CONNECTION_POOL || '10'),
      timeout: parseInt(process.env.DB_TIMEOUT || '30000'),
      retries: parseInt(process.env.DB_RETRIES || '3'),
    },
  };
};
```

### 6. Query Optimization
- Implement pagination for large datasets
- Use proper indexing strategies
- Implement caching where appropriate
- Monitor query performance

## Service Layer Guidelines

### 1. Service Implementation (BUSINESS LOGIC ONLY)
```typescript
export class MenuService implements IMenuService {
  constructor(
    private readonly menuRepository: IMenuRepository,
    private readonly validationService: IValidationService,
    private readonly eventBus: IEventBus,
    private readonly menuValidator: IMenuValidator
  ) {}
  
  async createMenu(command: CreateMenuCommand): Promise<Result<Menu>> {
    // 1. VALIDATION (Service Layer Responsibility)
    const validation = await this.menuValidator.validateCreateCommand(command);
    if (!validation.success) {
      return Result.failure(validation.errors);
    }
    
    // 2. BUSINESS LOGIC (Service Layer Responsibility)
    const menu = this.createMenuEntity(command);
    this.applyBusinessRules(menu);
    
    // 3. PERSISTENCE (Delegate to Repository)
    const menuId = await this.menuRepository.create(menu);
    
    // 4. EVENTS (Service Layer Responsibility)
    await this.eventBus.publish(new MenuCreatedEvent(menuId, command.placeId));
    
    return Result.success(menu);
  }
  
  private createMenuEntity(command: CreateMenuCommand): Menu {
    // Business logic for entity creation
    return new Menu(/* ... */);
  }
  
  private applyBusinessRules(menu: Menu): void {
    // Business rules application
    if (menu.getItems().length === 0) {
      throw new BusinessRuleViolationError('Menu must have at least one item');
    }
  }
}
```

### 2. Business Logic Rules
- Keep services focused on single responsibility
- Use domain events for side effects
- Implement proper authorization checks
- Handle concurrent access scenarios

## API Design

### 1. Response Format
```typescript
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  message?: string;
  errors?: string[];
  metadata?: {
    timestamp: string;
    version: string;
    requestId: string;
  };
}
```

### 2. Error Responses
- Use consistent HTTP status codes
- Provide meaningful error messages
- Include request ID for tracking
- Log errors with proper context

## Security Guidelines

### 1. Authentication & Authorization
- Implement proper Firebase Auth integration
- Use role-based access control (RBAC)
- Validate user permissions at service level
- Implement rate limiting

### 2. Input Validation
- Sanitize all user inputs
- Use parameterized queries
- Implement proper CORS policies
- Validate file uploads

## Performance Guidelines

### 1. Caching Strategy
- Implement Redis for session data
- Use in-memory caching for frequently accessed data
- Implement cache invalidation strategies
- Monitor cache hit rates

### 2. Database Optimization
- Use connection pooling
- Implement query result caching
- Monitor slow queries
- Use appropriate indexes

## Monitoring & Logging

### 1. Logging
- Use structured logging (JSON format)
- Include correlation IDs
- Log at appropriate levels (DEBUG, INFO, WARN, ERROR)
- Implement log aggregation

### 2. Metrics
- Track API response times
- Monitor error rates
- Track business metrics
- Implement health checks

## Code Quality

### 1. Linting & Formatting
- Use ESLint with TypeScript rules
- Use Prettier for code formatting
- Enforce consistent code style
- Use pre-commit hooks

### 2. Documentation
- Document all public APIs
- Use JSDoc for complex functions
- Maintain README files
- Document deployment procedures

## Deployment & DevOps

### 1. Environment Management
- Use environment variables for configuration
- Implement proper secrets management
- Use different configs for dev/staging/prod
- Implement feature flags

### 2. CI/CD
- Automate testing and building
- Implement deployment pipelines
- Use infrastructure as code
- Monitor deployment health

## Summary of Key Principles (MANDATORY)

### ðŸš« What NOT to do:
- **NO business logic in repositories**
- **NO business logic in controllers**
- **NO validation in repositories**
- **NO business rules in infrastructure layer**
- **NO direct database calls in services**
- **NO presentation logic in services**

### âœ… What TO do:
- **ALL business logic goes in services**
- **ALL validation goes in services**
- **ALL repositories extend BaseRepository**
- **ALL dependencies injected via constructor**
- **ALL interfaces over concrete implementations**
- **ALL SOLID principles strictly followed**

### ðŸ”„ Data Flow:
```
Controller â†’ Service â†’ Repository â†’ Database
    â†“           â†“         â†“
  NO LOGIC   ALL LOGIC  NO LOGIC
```
