# Backend Architecture & Coding Standards

## Architecture Patterns

### 1. SOLID Principles & Clean Architecture
- **Single Responsibility Principle**: Each class has one reason to change
- **Open/Closed Principle**: Open for extension, closed for modification
- **Liskov Substitution Principle**: Derived classes can substitute base classes
- **Interface Segregation Principle**: Clients depend only on interfaces they use
- **Dependency Inversion Principle**: High-level modules don't depend on low-level modules

### 2. Layered Architecture (Clean Architecture)
- **Presentation Layer**: Controllers/Handlers (Firebase Functions) - NO BUSINESS LOGIC
- **Application Layer**: Services (Business Logic ONLY) - NO DATA ACCESS
- **Domain Layer**: Entities, Value Objects, Domain Services - PURE BUSINESS RULES
- **Infrastructure Layer**: Repositories, Database Clients, External Services - NO BUSINESS LOGIC

### 3. Repository Pattern (MANDATORY)
- **ALL repositories MUST extend `IBaseRepository<T>` interface**
- **ALL repositories MUST inherit from `BaseRepository<T>` abstract class**
- Implement concrete repositories (Firebase, PostgreSQL, etc.) ONLY for specific database logic
- Repository should handle data persistence concerns ONLY
- **ABSOLUTELY NO business logic in repositories**
- **ABSOLUTELY NO validation in repositories**
- **ABSOLUTELY NO business rules in repositories**

### 4. Service Layer Pattern (BUSINESS LOGIC ONLY)
- **Services contain ALL business logic and orchestration**
- **Services use repositories for data access ONLY**
- **Services handle ALL validation, business rules, and transactions**
- **Services are stateless and injectable**
- **Services implement SOLID principles strictly**
- **Services follow Single Responsibility Principle**
- **Services contain NO data access logic**
- **Services contain NO presentation logic**

### 5. Dependency Injection (MANDATORY)
- **Use constructor injection for ALL dependencies**
- **Prefer interfaces over concrete implementations ALWAYS**
- **Use factory patterns for complex object creation**
- **Follow Dependency Inversion Principle strictly**
- **High-level modules depend on abstractions, not concretions**
- **Use dependency injection container for complex dependency graphs**

## Code Organization

### Directory Structure
```
src/
‚îú‚îÄ‚îÄ controllers/          # Presentation layer (Firebase Functions)
‚îú‚îÄ‚îÄ services/            # Business logic layer
‚îú‚îÄ‚îÄ repositories/        # Data access layer
‚îú‚îÄ‚îÄ entities/            # Domain models
‚îú‚îÄ‚îÄ value-objects/       # Immutable value objects
‚îú‚îÄ‚îÄ domain-services/     # Domain-specific business logic
‚îú‚îÄ‚îÄ infrastructure/      # External services, database clients
‚îú‚îÄ‚îÄ shared/              # Utilities, constants, types
‚îî‚îÄ‚îÄ middleware/          # Cross-cutting concerns
```

### File Naming Conventions
- **Controllers**: `*.controller.ts` (e.g., `menu.controller.ts`)
- **Services**: `*.service.ts` (e.g., `menu.service.ts`)
- **Repositories**: `*.repository.ts` (e.g., `menu.repository.ts`)
- **Entities**: `*.entity.ts` (e.g., `menu.entity.ts`)
- **Interfaces**: `I*.ts` (e.g., `IMenuRepository.ts`)

## Coding Standards

### 1. TypeScript Best Practices (SOLID COMPLIANT)
- Use strict TypeScript configuration
- **Prefer interfaces over types for object shapes ALWAYS**
- **Use generic types for reusable components**
- **Implement proper error handling with custom error types**
- **Use abstract classes for base implementations**
- **Use interfaces for contracts and abstractions**
- **Follow Interface Segregation Principle**
- **Use composition over inheritance when possible**

### 2. Error Handling (CLEAN CODE)
- **Create custom error classes extending `Error`**
- **Use Result pattern for operations that can fail**
- **Implement proper error logging and monitoring**
- **Return consistent error responses**
- **Use meaningful error messages**
- **Implement proper error hierarchy**
- **Handle errors at appropriate layers**
- **Log errors with context and correlation IDs**

### 3. Validation (SERVICE LAYER ONLY)
- **Use Zod for runtime validation**
- **Validate input at service boundaries ONLY**
- **Implement proper sanitization for user inputs**
- **Use DTOs for data transfer**
- **NO validation in repositories**
- **NO validation in controllers**
- **ALL validation happens in services**
- **Use validation decorators for complex validation rules**

### 7. Testing Database Clients (MANDATORY)
```typescript
// Mock database client for testing
export class MockDatabaseClient implements IDatabaseClient {
  private connected = false;
  
  async connect(): Promise<void> {
    this.connected = true;
  }
  
  async disconnect(): Promise<void> {
    this.connected = false;
  }
  
  isConnected(): boolean {
    return this.connected;
  }
  
  getConnection(): any {
    return { mock: true };
  }
}

// Test the factory
describe('DatabaseClientFactory', () => {
  it('should create Firebase client', () => {
    const config: DatabaseConfig = { type: 'firebase', credentials: {} };
    const client = DatabaseClientFactory.createClient(config);
    expect(client).toBeInstanceOf(FirebaseClient);
  });
  
  it('should create PostgreSQL client', () => {
    const config: DatabaseConfig = { type: 'postgresql', credentials: {} };
    const client = DatabaseClientFactory.createClient(config);
    expect(client).toBeInstanceOf(PostgreSQLClient);
  });
  
  it('should throw error for unsupported type', () => {
    const config: DatabaseConfig = { type: 'unsupported' as any, credentials: {} };
    expect(() => DatabaseClientFactory.createClient(config)).toThrow();
  });
});
```

### 8. Testing
- Write unit tests for services
- Mock repositories in service tests
- Use Jest for testing framework
- Aim for 80%+ code coverage

## Database Patterns

### 1. Database Client Factory Pattern (MANDATORY)
```typescript
// Database Client Factory - Simple and Clean
export class DatabaseClientFactory {
  static createClient(config: DatabaseConfig): IDatabaseClient {
    switch (config.type) {
      case 'firebase':
        return new FirebaseClient(config.credentials);
      case 'postgresql':
        return new PostgreSQLClient(config.credentials);
      case 'mongodb':
        return new MongoDBClient(config.credentials);
      default:
        throw new Error(`Unsupported database type: ${config.type}`);
    }
  }
}

// Configuration-driven selection
export const databaseConfig: DatabaseConfig = {
  type: process.env.DB_TYPE || 'firebase',
  credentials: {
    // Environment-based credentials
  }
};

// Usage in repository
const client = DatabaseClientFactory.createClient(databaseConfig);
```

### 2. Repository Implementation (MANDATORY BASE REPO)
```typescript
// ALL repositories MUST extend BaseRepository
export class MenuRepository extends BaseRepository<Menu> implements IMenuRepository {
  constructor() {
    // Use factory to get appropriate client
    const client = DatabaseClientFactory.createClient(databaseConfig);
    super(client, 'menus');
  }
  
  // Implement ONLY specific business queries
  // ALL CRUD operations come from BaseRepository
  async findByPlaceId(placeId: string): Promise<Menu | null> {
    return this.findOne([{ field: 'placeId', operator: '==', value: placeId }]);
  }
}
```

### 3. Database Client Interfaces (MANDATORY)
```typescript
// Base interface for all database operations
export interface IDatabaseClient {
  connect(): Promise<void>;
  disconnect(): Promise<void>;
  isConnected(): boolean;
  getConnection(): any; // Database-specific connection object
}

// Firebase-specific client
export class FirebaseClient implements IDatabaseClient {
  constructor(private credentials: FirebaseCredentials) {}
  
  async connect(): Promise<void> {
    // Firebase connection logic
  }
  
  async disconnect(): Promise<void> {
    // Firebase disconnection logic
  }
  
  isConnected(): boolean {
    // Firebase connection check
    return true; // Firebase is always connected
  }
  
  getConnection(): any {
    return firebase.app();
  }
}

// PostgreSQL-specific client
export class PostgreSQLClient implements IDatabaseClient {
  constructor(private credentials: PostgresCredentials) {}
  
  async connect(): Promise<void> {
    // PostgreSQL connection logic
  }
  
  async disconnect(): Promise<void> {
    // PostgreSQL disconnection logic
  }
  
  isConnected(): boolean {
    // PostgreSQL connection check
    return this.client?.connected || false;
  }
  
  getConnection(): any {
    return this.client;
  }
}
```

### 4. Transaction Management
- Use database transactions for multi-step operations
- Implement Unit of Work pattern for complex operations
- Handle rollback scenarios gracefully

### 5. Environment Configuration (MANDATORY)
```typescript
// Environment-based database configuration
export interface DatabaseConfig {
  type: 'firebase' | 'postgresql' | 'mongodb';
  credentials: Record<string, unknown>;
  options?: {
    connectionPool?: number;
    timeout?: number;
    retries?: number;
  };
}

// Load configuration from environment
export const getDatabaseConfig = (): DatabaseConfig => {
  const dbType = process.env.DB_TYPE || 'firebase';
  
  if (!['firebase', 'postgresql', 'mongodb'].includes(dbType)) {
    throw new Error(`Invalid database type: ${dbType}`);
  }
  
  return {
    type: dbType as DatabaseConfig['type'],
    credentials: {
      // Load credentials based on database type
      ...(dbType === 'firebase' && {
        projectId: process.env.FIREBASE_PROJECT_ID,
        privateKey: process.env.FIREBASE_PRIVATE_KEY,
        clientEmail: process.env.FIREBASE_CLIENT_EMAIL,
      }),
      ...(dbType === 'postgresql' && {
        host: process.env.POSTGRES_HOST,
        port: process.env.POSTGRES_PORT,
        database: process.env.POSTGRES_DB,
        username: process.env.POSTGRES_USER,
        password: process.env.POSTGRES_PASSWORD,
      }),
    },
    options: {
      connectionPool: parseInt(process.env.DB_CONNECTION_POOL || '10'),
      timeout: parseInt(process.env.DB_TIMEOUT || '30000'),
      retries: parseInt(process.env.DB_RETRIES || '3'),
    },
  };
};
```

### 6. Query Optimization
- Implement pagination for large datasets
- Use proper indexing strategies
- Implement caching where appropriate
- Monitor query performance

## Service Layer Guidelines

### 1. Service Implementation (BUSINESS LOGIC ONLY)
```typescript
export class MenuService implements IMenuService {
  constructor(
    private readonly menuRepository: IMenuRepository,
    private readonly validationService: IValidationService,
    private readonly eventBus: IEventBus,
    private readonly menuValidator: IMenuValidator
  ) {}
  
  async createMenu(command: CreateMenuCommand): Promise<Result<Menu>> {
    // 1. VALIDATION (Service Layer Responsibility)
    const validation = await this.menuValidator.validateCreateCommand(command);
    if (!validation.success) {
      return Result.failure(validation.errors);
    }
    
    // 2. BUSINESS LOGIC (Service Layer Responsibility)
    const menu = this.createMenuEntity(command);
    this.applyBusinessRules(menu);
    
    // 3. PERSISTENCE (Delegate to Repository)
    const menuId = await this.menuRepository.create(menu);
    
    // 4. EVENTS (Service Layer Responsibility)
    await this.eventBus.publish(new MenuCreatedEvent(menuId, command.placeId));
    
    return Result.success(menu);
  }
  
  private createMenuEntity(command: CreateMenuCommand): Menu {
    // Business logic for entity creation
    return new Menu(/* ... */);
  }
  
  private applyBusinessRules(menu: Menu): void {
    // Business rules application
    if (menu.getItems().length === 0) {
      throw new BusinessRuleViolationError('Menu must have at least one item');
    }
  }
}
```

### 2. Business Logic Rules
- Keep services focused on single responsibility
- Use domain events for side effects
- Implement proper authorization checks
- Handle concurrent access scenarios

## API Design

### 1. Response Format
```typescript
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  message?: string;
  errors?: string[];
  metadata?: {
    timestamp: string;
    version: string;
    requestId: string;
  };
}
```

### 2. Error Responses
- Use consistent HTTP status codes
- Provide meaningful error messages
- Include request ID for tracking
- Log errors with proper context

## Security Guidelines

### 1. Authentication & Authorization
- Implement proper Firebase Auth integration
- Use role-based access control (RBAC)
- Validate user permissions at service level
- Implement rate limiting

### 2. Input Validation
- Sanitize all user inputs
- Use parameterized queries
- Implement proper CORS policies
- Validate file uploads

## Performance Guidelines

### 1. Caching Strategy
- Implement Redis for session data
- Use in-memory caching for frequently accessed data
- Implement cache invalidation strategies
- Monitor cache hit rates

### 2. Database Optimization
- Use connection pooling
- Implement query result caching
- Monitor slow queries
- Use appropriate indexes

## Monitoring & Logging

### 1. Logging
- Use structured logging (JSON format)
- Include correlation IDs
- Log at appropriate levels (DEBUG, INFO, WARN, ERROR)
- Implement log aggregation

### 2. Metrics
- Track API response times
- Monitor error rates
- Track business metrics
- Implement health checks

## Code Quality

### 1. Linting & Formatting
- Use ESLint with TypeScript rules
- Use Prettier for code formatting
- Enforce consistent code style
- Use pre-commit hooks

### 2. Documentation
- Document all public APIs
- Use JSDoc for complex functions
- Maintain README files
- Document deployment procedures

## Deployment & DevOps

### 1. Environment Management
- Use environment variables for configuration
- Implement proper secrets management
- Use different configs for dev/staging/prod
- Implement feature flags

### 2. CI/CD
- Automate testing and building
- Implement deployment pipelines
- Use infrastructure as code
- Monitor deployment health

## Summary of Key Principles (MANDATORY)

### üö´ What NOT to do:
- **NO business logic in repositories**
- **NO business logic in controllers**
- **NO validation in repositories**
- **NO business rules in infrastructure layer**
- **NO direct database calls in services**
- **NO presentation logic in services**

### ‚úÖ What TO do:
- **ALL business logic goes in services**
- **ALL validation goes in services**
- **ALL repositories extend BaseRepository**
- **ALL dependencies injected via constructor**
- **ALL interfaces over concrete implementations**
- **ALL SOLID principles strictly followed**

### üîÑ Data Flow:
```
Controller ‚Üí Service ‚Üí Repository ‚Üí Database
    ‚Üì           ‚Üì         ‚Üì
  NO LOGIC   ALL LOGIC  NO LOGIC
```

# TabNorder Backend - API Structure Rules

## RESTful API Structure Standards (Firebase Functions)

### Core Principles

1. **Single Resource Endpoint**: Each resource (items, orders, etc.) should have ONE Firebase Function that handles all operations
2. **Simple Path Structure**: Use path parameters ONLY for resource IDs, NO nested paths
3. **Query Parameters for Everything Else**: All filters, searches, and operations use query parameters
4. **HTTP Methods**: Use proper HTTP methods for operations:
   - `GET` - Retrieve data (list or single item)
   - `POST` - Create new resource
   - `PUT` - Update existing resource (full update)
   - `DELETE` - Delete resource

### Standard API Structure Pattern

#### Resource Endpoints

```
GET    /items              - List items with optional filters (query params)
POST   /items              - Create new item
GET    /items/{id}         - Get single item by ID
PUT    /items/{id}         - Update item by ID
DELETE /items/{id}         - Delete item by ID
```

#### Query Parameters for Filtering

All filters use query parameters on the collection endpoint:

```
GET /items?category_id=xxx&menu_id=xxx&is_available=true&search=xxx
```

**Query Parameters Pattern:**
- Use snake_case for parameter names: `category_id`, `menu_id`, `is_available`
- Combine multiple filters: `/items?category_id=xxx&menu_id=xxx&is_available=true`
- Use query params for all filtering, searching, and operations

**Examples:**
- ‚úÖ `GET /items?category_id=123` - Get items by category
- ‚úÖ `GET /items?menu_id=456&is_available=true` - Get available items in menu
- ‚úÖ `GET /items?search=pizza` - Search items
- ‚úÖ `GET /items?category_id=123&is_available=true&limit=10` - Multiple filters

**NOT Separate Endpoints:**
- ‚ùå `/items/category` 
- ‚ùå `/items/available`
- ‚ùå `/items/search`
- ‚ùå `/items/{id}/status`
- ‚ùå `/cart/{cartId}/discount`
- ‚ùå `/cart/{cartId}/items`

**Instead Use Query Parameters:**
- ‚úÖ `/items?category_id=xxx`
- ‚úÖ `/items?is_available=true`
- ‚úÖ `/items?search=xxx`
- ‚úÖ `/cart?cart_id=xxx&action=apply_discount&discount_code=xxx`
- ‚úÖ `/cart?cart_id=xxx&action=add_item&item_id=xxx&quantity=2`

### Implementation Pattern (Firebase Functions)

#### 1. Single Firebase Function per Resource

```typescript
export const items = onRequest({
  maxInstances: 10,
  cors: corsOrigins
}, async (request, response) => {
  try {
    const wasHandled = CorsMiddleware.handleCors(request, response);
    if (wasHandled) return;

    const controller = new ItemsController();
    
    // Extract path and parse it
    const path = request.path || request.url.split('?')[0];
    const pathParts = path.split('/').filter(p => p);
    
    // Extract ID from path: /items/{id}
    // pathParts[0] = 'items', pathParts[1] = '{id}' (if exists)
    const resourceId = pathParts[1]; // ID is second segment (after 'items')

    if (request.method === 'GET') {
      if (resourceId) {
        // GET /items/{id} - Get single item
        await controller.getItemById(request, response);
      } else {
        // GET /items?category_id=xxx&menu_id=xxx - List with filters
        await controller.getItems(request, response);
      }
    }
    else if (request.method === 'POST') {
      // POST /items - Create new item
      await controller.createItem(request, response);
    }
    else if (request.method === 'PUT') {
      if (resourceId) {
        // PUT /items/{id} - Update item
        await controller.updateItem(request, response);
      } else {
        response.status(400).json({ success: false, message: 'Item ID required' });
      }
    }
    else if (request.method === 'DELETE') {
      if (resourceId) {
        // DELETE /items/{id} - Delete item
        await controller.deleteItem(request, response);
      } else {
        response.status(400).json({ success: false, message: 'Item ID required' });
      }
    }
    else {
      response.status(405).json({ success: false, message: 'Method not allowed' });
    }
  } catch (error) {
    // Error handling
  }
});
```

#### 2. Path Parameter Extraction (Firebase Functions)

```typescript
// Extract ID from Firebase Functions request
const path = request.path || request.url.split('?')[0];
const pathParts = path.split('/').filter(p => p);

// Examples:
// /items/123 -> pathParts = ['items', '123'], resourceId = '123'
// /items?category_id=xxx -> pathParts = ['items'], resourceId = undefined
// /orders/456 -> pathParts = ['orders', '456'], resourceId = '456'

const resourceId = pathParts[1]; // ID is always second segment
// NO nested paths - keep it simple!
```

#### 3. Controller Method for List with Filters

```typescript
/**
 * Get items with optional filters
 * GET /items?category_id=xxx&menu_id=xxx&is_available=true&search=xxx
 */
getItems = async (request: Request, response: Response): Promise<void> => {
  try {
    const query: ItemQuery = {
      menuId: request.query.menu_id as string,
      categoryId: request.query.category_id as string,
      isAvailable: request.query.is_available === 'true' ? true : 
                  request.query.is_available === 'false' ? false : undefined,
      search: (request.query.search || request.query.q) as string
    };

    const items = await this.itemService.queryItems(query);
    
    response.status(200).json({
      success: true,
      data: items,
      count: items.length
    });
  } catch (error) {
    this.handleError(response, error);
  }
};
```

### Order API Structure

#### Standard Order Endpoints

```
GET    /orders                    - List orders with filters (query params)
POST   /orders                    - Create new order
GET    /orders/{id}               - Get order by ID
PUT    /orders/{id}               - Update order (use query param for status: ?status=xxx)
DELETE /orders/{id}               - Delete order
```

#### Query Parameters for Orders

```
GET /orders?place_id=xxx&status=xxx&type=xxx&customer_id=xxx&date_from=xxx&date_to=xxx&order_number=xxx
```

**Query Parameters (snake_case):**
- `place_id` - Filter by place ID
- `status` - Filter by status (pending, confirmed, preparing, ready, completed, cancelled)
- `type` - Filter by type (dine_in, takeout, delivery, pickup)
- `customer_id` - Filter by customer ID
- `date_from` - Filter from date (ISO date-time)
- `date_to` - Filter to date (ISO date-time)
- `order_number` - Filter by order number
- `source` - Filter by source (pos, online, mobile_app, phone)
- `search` or `q` - Search term

**Update Order Status:**
- `PUT /orders/{id}?status=confirmed&last_updated_by=user123` - Update status via query param

### Real-time Endpoints

Real-time endpoints are separate functions:

```
GET /ordersRealtime?place_id=xxx&status=xxx
GET /orderRealtimeStatus?place_id=xxx&status=xxx
GET /orderRealtimeSingle?id=xxx
```

### Cart API Structure

```
GET    /cart/{id}                 - Get cart by ID
POST   /cart                      - Create new cart
PUT    /cart/{id}                 - Update cart
DELETE /cart/{id}                - Delete cart
GET    /cart?place_id=xxx         - Get carts by place (with filters)
GET    /cart?customer_id=xxx     - Get carts by customer (with filters)
GET    /cart?customer_id=xxx&place_id=xxx&status=active - Get active cart
POST   /cart?cart_id=xxx&action=add_item&item_id=xxx&quantity=2 - Add item
PUT    /cart?cart_id=xxx&item_id=xxx&action=update&quantity=3 - Update item
DELETE /cart?cart_id=xxx&item_id=xxx&action=remove_item - Remove item
POST   /cart?cart_id=xxx&action=clear - Clear all items
POST   /cart?cart_id=xxx&action=apply_discount&discount_code=xxx - Apply discount
DELETE /cart?cart_id=xxx&action=remove_discount - Remove discount
POST   /cart?cart_id=xxx&action=convert - Convert cart to order
```

**Key Principle:** Use query parameters with `action` parameter for cart operations, NOT nested paths!

### Path Parameter Naming

- Use `{id}` for resource IDs ONLY: `/items/{id}`, `/orders/{id}`, `/cart/{id}`
- **NO nested paths**: ‚ùå `/cart/{cartId}/discount`, ‚ùå `/orders/{id}/status`
- **Use query parameters instead**: ‚úÖ `/cart?cart_id=xxx&action=apply_discount`

### Error Responses

All endpoints should return consistent error responses:

```typescript
{
  "success": false,
  "message": "Error message",
  "error": "Error type",
  "errors": ["Array of validation errors"]
}
```

### Success Responses

```typescript
{
  "success": true,
  "data": { /* resource data */ },
  "message": "Success message",
  "count": 10, // For list endpoints
  "metadata": {
    "timestamp": "2024-01-15T10:30:00.000Z",
    "version": "1.0.0",
    "requestId": "xxx"
  }
}
```

### Firebase Functions Naming

Firebase Functions are named after the resource, not the operation:

- ‚úÖ `export const items = onRequest(...)` ‚Üí `/items`
- ‚úÖ `export const orders = onRequest(...)` ‚Üí `/orders`
- ‚úÖ `export const cart = onRequest(...)` ‚Üí `/cart`
- ‚ùå `export const itemDetail = onRequest(...)` ‚Üí `/itemDetail` (WRONG)
- ‚ùå `export const orderDetail = onRequest(...)` ‚Üí `/orderDetail` (WRONG)

### Migration Checklist

When refactoring to this structure:

1. ‚úÖ Consolidate multiple functions into single resource function
2. ‚úÖ Implement path parameter extraction from `request.path`
3. ‚úÖ Move all filter logic to query parameters
4. ‚úÖ Remove separate endpoints for category, search, available, etc.
5. ‚úÖ Update Swagger documentation to match actual implementation
6. ‚úÖ Ensure all controller methods are properly routed
7. ‚úÖ Test all query parameter combinations
8. ‚úÖ Verify path parameter extraction works correctly

### Examples

#### Good Structure ‚úÖ

```typescript
// Single function handles all item operations
export const items = onRequest({...}, async (request, response) => {
  const pathParts = request.path.split('/').filter(p => p);
  const itemId = pathParts[1];
  
  if (request.method === 'GET' && itemId) {
    // GET /items/{id}
  } else if (request.method === 'GET') {
    // GET /items?category_id=xxx&menu_id=xxx
  } else if (request.method === 'POST') {
    // POST /items
  }
  // etc.
});
```

#### Bad Structure ‚ùå

```typescript
// Multiple functions for same resource
export const items = onRequest({...}, ...); // Only GET /items?menu_id=xxx
export const itemDetail = onRequest({...}, ...); // GET /itemDetail/{id}
export const itemsCategory = onRequest({...}, ...); // GET /itemsCategory?category=xxx

// Nested paths (DON'T DO THIS)
export const cartDiscount = onRequest({...}, ...); // POST /cart/{cartId}/discount
export const cartItems = onRequest({...}, ...); // POST /cart/{cartId}/items

// Instead use query parameters:
// POST /cart?cart_id=xxx&action=apply_discount&discount_code=xxx
// POST /cart?cart_id=xxx&action=add_item&item_id=xxx&quantity=2
```

### Summary

- **One Firebase Function per resource** (items, orders, cart, etc.)
- **Path parameters ONLY for resource IDs**: `/items/{id}`, `/orders/{id}`, `/cart/{id}`
- **Query parameters for EVERYTHING ELSE**: 
  - Filters: `/items?category_id=xxx&menu_id=xxx`
  - Actions: `/cart?cart_id=xxx&action=apply_discount`
  - Search: `/items?search=xxx`
- **NO nested paths**: ‚ùå `/cart/{cartId}/discount`, ‚úÖ `/cart?cart_id=xxx&action=apply_discount`
- **Use snake_case for query parameters**: `category_id`, `menu_id`, `is_available`
- **HTTP methods for operations**: GET, POST, PUT, DELETE
- **No separate endpoints for filters**: Use query params instead
- **Consistent error/success responses**
- **Proper path parsing** from `request.path` (Firebase Functions)
